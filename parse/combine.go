package parse

type (
	// Combiner takes multiple Result values and combines them into one
	Combiner func(...Result) Result

	// Results represents multiple Results that have been combined. This
	// is usually the result of the Bind or Then combinators
	Results []Result
)

// Concat returns a new Parser, the Result of which is generated by
// concatenating the Results of the provided Parsers
func Concat(l Parser, r Parser) Parser {
	return l.Bind(func(lr Result) Parser {
		return r.Bind(func(rr Result) Parser {
			return Return(concatResults(lr, rr))
		})
	})
}

// Combine returns a new Parser, the Result of which is a value
// generated by passing any Combined results to the provided Combiner
func Combine(p Parser, fn Combiner) Parser {
	return p.Map(func(r Result) Result {
		if res, ok := r.(Results); ok {
			return fn(res...)
		}
		return fn(r)
	})
}

// OneOrMore returns a new Parser, the Result of which is the Combined
// set of values matched by the provided Parser being performed one or
// more times
func OneOrMore(p Parser) Parser {
	return nOrMore(1, p)
}

// ZeroOrMore returns a new Parser, the Result of which is the Combined
// set of values matched by the provided Parser being performed zero or
// more times
func ZeroOrMore(p Parser) Parser {
	return nOrMore(0, p)
}

func nOrMore(min int, p Parser) Parser {
	return func(i Input) (*Success, *Failure) {
		var res Results
		next := i
		for count := 0; ; count++ {
			s, f := p(next)
			if f == nil {
				res = append(res, s.Result)
				next = s.Remaining
				continue
			}
			if count >= min {
				return next.succeedWith(res)
			}
			return nil, f
		}
	}
}

func concatResults(l, r Result) Results {
	var res Results
	res = appendResults(res, l)
	res = appendResults(res, r)
	return res
}

func appendResults(res Results, r Result) Results {
	if c, ok := r.(Results); ok {
		return append(res, c...)
	}
	return append(res, r)
}

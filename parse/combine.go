package parse

// Combiner takes multiple Result values and combines them into one
type Combiner func(...Result) Result

// Combine returns a new Parser, the Result of which is a value
// generated by passing any Combined results to the provided Combiner
func Combine(p Parser, fn Combiner) Parser {
	return p.Map(func(r Result) Result {
		res := appendResults(Results{}, r)
		return fn(res...)
	})
}

// OneOrMore returns a new Parser, the Result of which is the Combined
// set of values matched by the provided Parser being performed one or
// more times
func OneOrMore(p Parser) Parser {
	return nOrMore(1, p)
}

// ZeroOrMore returns a new Parser, the Result of which is the Combined
// set of values matched by the provided Parser being performed zero or
// more times
func ZeroOrMore(p Parser) Parser {
	return nOrMore(0, p)
}

func nOrMore(min int, p Parser) Parser {
	return func(i Input) (*Success, *Failure) {
		var res Results
		next := i
		for count := 0; ; count++ {
			s, f := p(next)
			if f == nil {
				res = append(res, s.Result)
				next = s.Remaining
				continue
			}
			if count >= min {
				return next.succeedWith(res)
			}
			return nil, f
		}
	}
}

package parse

type (
	// Combiner takes multiple Result values and combines them into one
	Combiner func(...Result) Result

	// Results represents multiple Results that have been combined. This
	// is usually the result of the Bind or Then combinators
	Results []Result
)

// Concat returns a new Parser, the Result of which is generated by
// concatenating the Results of the provided Parsers
func Concat(l Parser, r Parser) Parser {
	return l.Bind(func(lr Result) Parser {
		return r.Bind(func(rr Result) Parser {
			return Return(concatResults(lr, rr))
		})
	})
}

// Combine returns a new Parser, the Result of which is a value
// generated by passing any Combined results to the provided Combiner
func Combine(p Parser, fn Combiner) Parser {
	return p.Map(func(r Result) Result {
		if res, ok := r.(Results); ok {
			return fn(res...)
		}
		return fn(r)
	})
}

// OneOrMore returns a new Parser, the Result of which is the Combined
// set of values matched by the provided Parser being performed one or
// more times
func OneOrMore(p Parser) Parser {
	return Concat(p, ZeroOrMore(p))
}

// ZeroOrMore returns a new Parser, the Result of which is the Combined
// set of values matched by the provided Parser being performed zero or
// more times
func ZeroOrMore(p Parser) Parser {
	return Or(
		p.Bind(func(r Result) Parser {
			return Concat(Return(r), ZeroOrMore(p))
		}),
		Return(Results{}),
	)
}

func concatResults(l, r Result) Results {
	var res Results
	res = appendResults(res, l)
	res = appendResults(res, r)
	return res
}

func appendResults(res Results, r Result) Results {
	if c, ok := r.(Results); ok {
		return append(res, c...)
	}
	return append(res, r)
}
